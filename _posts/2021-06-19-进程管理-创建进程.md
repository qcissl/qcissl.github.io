---
layout:     post
title:      "进程管理"
subtitle:   "创建进程"
header-img: "img/content/c-15.jpg"
header-mask: 0.2
tags:
    - Linux内核设计与实现
---



## 3.3 创建进程

​		Unix中的进程创建是唯一的。大多数操作系统都实现了派生机制，在新的地址空间中创建一个新进程，读入可执行文件，然后开始执行它。Unix采用了一种不同寻常的方法，将这些步骤分隔为两个不同的函数:fork()和exec()。首先fork()创建了一个子进程，它是当前任务的副本。它与父进程的不同之处在于它的PID(唯一的)，它的PPID(父进程的PID，被设置为原始进程)，以及某些不被继承的资源和统计信息，如挂起信号。其次函数exec()将一个新的可执行文件加载到地址空间并开始执行它。fork()和exec()的组合类似于大多数操作系统提供的单个函数。



### 3.3.1 写时拷贝

​		传统的fork()系统调用，父类拥有的所有资源都会被复制，并将复制给子类。这种方法很简单，效率也很低，因为它复制了很多本来可以共享的数据。更糟糕的是，如果新进程立即执行一个新映像，那么所有复制都将浪费掉。在Linux中，fork()是通过使用写时复制页来实现的。写时拷贝(Copy-on-write, COW)是一种推迟甚至完全防止避免数据copy的技术。父进程和子进程可以共享一个副本，而不是复制进程地址空间。

​		只有在需要写入的时候，数据才会被copy，从而使各自进程拥有各自的副本。因此，资源的复制只发生在写入的时候；在此之前，它们是只读的方式共享。这种技术延迟了地址空间中每一页的复制，直到它真正被写入是才进行copy。例如，在没有写入页面的情况下，如果在fork()之后立即调用exec()，则永远不需要复制这些页面。

​		fork()引起的唯一开销是复制父进程的页表和为子进程创建唯一的进程描述符。通常情况下，一个进程在创建后立即运行一个可执行文件，这种优化可以防止浪费大量数据的复制(地址空间很容易达到几十兆字节)。这是一个重要的优化，因为Unix理念鼓励快速执行进程。



### 3.3.2 fork()

​		Linux通过clone()系统调用来实现fork()。这个调用接受一系列参数标志，这些参数标志指定父进程和子进程应该共享哪些资源(如果有的话)。(有关标记的更多信息，请参阅本章后面的Linux线程实现部分)。`fork()`、`vfork()`和`__clone()`库调用都使用必要的参数标志调用clone()系统调用。clone()系统调用依次调用do_fork()。

​		fork中的大部分工作是由do_fork()处理的，它在`kernel/fork.c`中定义。这个函数调用copy_process()函数，然后启动进程运行。copy_process()完成的工作很有意思:

1. 它调用dup_task_struct()，它为新进程创建一个新的内核堆栈、thread_info结构体和task_struct。新值与当前进程的值相同。此时，子进程和父进程描述符是相同的。
2. 然后检查新子进程是否会超过当前用户的进程数的资源限制。
3. 子进程需要将自己与父进程区分开来。进程描述符的各个成员被清除或设置为初始值。未被继承的进程描述符的成员主要是统计信息；task_struct中的大部分值保持不变。
4. 子进程的状态被设置为TASK_UNINTERRUPTIBLE以确保它还没有运行。
5. copy_process()调用copy_flags()来更新task_struct的flags成员。清除PF_SUPERPRIV标志，表示任务是否具有超级用户权限。PF_FORKNOEXEC标志表示没有调用exec()的进程被设置。
6. 它调用`alloc_pid()`来为新任务分配一个可用的PID。
7. 根据传递给clone()的标志，copy_process()复制或共享打开的文件、文件系统信息、信号处理程序、进程地址空间和命名空间。这些资源通常在给定进程中的线程之间共享;否则它们是唯一的，因此在这里复制。
8.  最后，copy_process()清理并向调用者返回一个指向新子进程的指针。

​	   在do_fork()中，如果copy_process()函数成功返回，新的子进程将被唤醒并运行。内核会先运行子进程，通常情况下子进程会立即调用exec()，这就消除了父进程先运行并开始写入地址空间时可能出现的任何写时复制开销。



### 3.3.3 `vfork()`

​		`vfork()`系统调用与fork()具有相同的效果，只是父进程的页表项不被复制。相反，子线程作为父线程地址空间中的唯一线程执行，并且父线程被阻塞，直到子线程调用exec()或退出。不允许子对象写入地址空间。在3BSD的旧时代，当调用被引入时，这是一个受欢迎的优化，因为当时写时复制页没有被用于实现fork()。现在，使用写时拷贝(copy-on-write)和`child-runsfirst`语义，`vfork()`的唯一好处是不复制父页表项。如果有一天Linux获得了写时复制页表项，那么就不再有任何好处了因为`vfork()`的语义很复杂(例如，如果exec()失败会发生什么?)，理想情况下系统不需要`vfork()`，内核也不会实现它。将`vfork()`实现为普通的fork()是完全可能的，这是Linux 2.2版本之前所做的。

`vfork()`系统调用是通过克隆()系统调用的一个特殊标志实现的:

1. 在copy_process()中，task_struct成员`vfork_done`被设置为NULL。
2. 在do_fork()中，如果给定了特殊标志，`vfork_done`将指向一个特定的地址。
3. 子进程第一次运行后，父进程不会返回，而是等待子进程通过`vfork_done`指针发出信号。
4.  mm_release()函数用于任务退出内存地址空间时，检查`vfork_done`是否为NULL。如果不是，则通知父节点。
5.  在do_fork()中，父进程会被唤醒并返回。

​		如果这一切都按计划进行，子进程将在一个新的地址空间中执行，而父进程将再次在其原来的地址空间中执行。开销较低，但实现并不漂亮。