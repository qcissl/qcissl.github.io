---
layout:     post
title:      "系统调用"
subtitle:   "与内核通信"
header-img: "img/content/c-25.jpg"
header-mask: 0.2
tags:
    - Linux内核设计与实现
---



## 5.1 与内核通信

​		系统调用在硬件设备和用户空间进程之间添加了一个中间层。这一层有三个主要目的。

​		首先，它为用户空间提供了一个抽象的硬件接口。例如，当从一个文件读取或写入时，应用程序并不关心文件所在的磁盘、媒体甚至文件系统的类型。

​		其次，系统调用保证了系统的安全性和稳定性。内核作为系统资源和用户空间之间的中间人，内核可以根据权限、用户和其他条件的访问进行裁决。例如，可以防止应用程序错误地使用硬件、窃取其他进程资源或以其他方式损害系统。

​		最后，在第3章进程管理中讨论过，每个进程都运行在虚拟系统中，而在用户空间和系统的其他部分之间提供这样一层公共层，也是出于这种考虑。如果应用程序可以在不了解内核的情况下自由地访问系统资源，那么几乎不可能实现多任务和虚拟内存，当然也不可能在稳定和安全的情况下做到这一点。

​		在Linux中，系统调用是用户空间与内核接口的唯一方式；除了异常和陷入之外，它们是进入内核的唯一合法入口点。实际上，其他接口，如设备文件或/proc，最终是通过系统调用访问的。有趣的是，Linux实现的系统调用比大多数系统要少得多。本章介绍Linux系统调用的角色和实现。

### 5.2 API、POSIX和C库

​		通常，应用程序是根据用户空间中实现的应用程序编程接口(API)编写的，而不是直接针对系统调用。这一点很重要，因为应用程序所使用的接口与内核提供的实际接口之间不需要直接关联。API定义了一组应用程序使用的编程接口。这些接口可以作为系统调用实现，也可以通过多个系统调用实现，或者根本不使用系统调用实现。相同的API可以存在于多个系统中，并为应用程序提供相同的接口，而API本身的实现可能因系统而异。图5.1给出了POSIX API、C库和系统调用之间关系的示例。

![image-20210628060353631](/img/assets/linuxkerner/image-20210628060353631.png)

​		Unix世界中最常见的应用程序编程接口之一是基于POSIX标准的。从技术上讲，POSIX由IEEE2中的一系列标准组成，这些标准旨在提供一个大致基于Unix的可移植操作系统标准。Linux在适用的情况下努力做到POSIX和SUSv3兼容。

​		POSIX是API和系统调用之间关系的一个很好的例子。在大多数Unix系统上，POSIX定义的API调用与系统调用有很强的相关性。实际上，POSIX标准的创建是为了类似于早期Unix系统提供的接口。另一方面，一些非unix系统，如Microsoft Windows，提供了与posix兼容的库。

​		与大多数Unix系统一样，Linux中的系统调用接口部分由C库提供。C库实现了Unix系统上的主要API，包括标准C库和系统调用接口。所有C程序都使用C库，而且，由于C的本质，可以很容易地被其他编程语言包装，以便在它们的程序中使用。C库还提供了大部分POSIX API。

​		从应用程序程序员的角度来看，系统调用是无关紧要的；程序员关心的只是API。相反，内核只关心系统调用；库调用和应用程序使用系统调用的内容与内核无关。尽管如此，对于内核来说，重要的是要跟踪系统调用的潜在使用，并尽可能地保持系统调用的通用性和灵活性。

​		Unix中与接口相关的一个格言是“`提供机制，而不是策略`”。换句话说，存在Unix系统调用是为了在抽象意义上提供特定的函数。函数的使用方式与内核无关。
