---
layout:     post
title:      "进程管理"
subtitle:   "进程"
header-img: "img/content/c-12.jpg"
header-mask: 0.2
tags:
    - Linux内核设计与实现
---



## 3.1 进程

​		**进程是一个在执行过程中的程序**(目标代码存储在一些存储介质上)。

然而，进程不仅仅是执行的程序代码(*在Unix中通常称为文本部分*)。它们还包括一组资源，如：

- 打开的文件
- 挂起的信号
- 内部内核数据
- 处理器状态
- 一个或多个具有内存映射的内存地址空间
- 一个或多个执行线程
- 以及包含全局变量的数据段等。

实际上，进程是运行程序代码的活动结果。内核需要高效和透明地管理所有这些细节。

​		执行线程(通常简称为线程)是进程中的活动对象。**每个线程包括一个独特的程序计数器、进程堆栈和处理器寄存器集。**内核调度单个线程，而不是进程。在传统的Unix系统中，每个进程由一个线程组成。然而，在现代系统中，由多个线程组成的多线程程序是常见的。稍后您将看到，**Linux有一个独特的线程实现:它不区分线程和进程。对于Linux，线程只是一种特殊的进程**。

​		在现代操作系统上，**进程提供了两种虚拟化:虚拟处理器和虚拟内存**。虚拟处理器给进程一种它独占整个系统的假象，尽管它可能在数百个其他进程中共享处理器。第4章，进程调度，讨论了这种虚拟化。虚拟内存允许进程分配和管理内存，就像它自己拥有系统中的所有内存一样。虚拟内存将在第12章内存管理中讨论。**有趣的是，请注意在线程之间可以共享虚拟内存，但每个线程都有各自的虚拟处理器**。

​		程序本身不是一个进程，进程是执行中的程序和相关的资源的总称。实际上，可以存在两个或多个进程执行的是同一程序，并且可以存在两个或多个进程共享各种资源，比如打开的文件或地址空间。

​		毫无疑问，进程在创建时就开始存活。**在Linux中，这是通过fork()系统调用来实现的，它通过复制一个现有进程来创建一个新进程**。调用fork()的进程是父进程，而新进程是子进程。在返回点这个相同的地方，父进程恢复执行，子进程开始执行。fork()系统调用从内核返回两次:一次在父进程中，另一次在新生的子进程中。

​		通常，在创建一个新的进程是为了立即执行一个新的、不同的程序。调用exec()函数就可以创建一个新的地址空间，并将一个新程序加载到其中。在当代的Linux内核中，fork()实际上是通过clone()系统调用实现的，这将在下一节中讨论。

​		最后，程序通过exit()系统调用退出。这个函数终止进程并释放它的所有资源。父进程可以通过wait4()系统调用查询终止子进程的状态，这使得进程有了等待特定进程执行完毕的能力。当一个进程退出时，它会进入一个特殊的僵死状态，该状态表示终止的进程，直到父进程调用wait()或waitpid()。

> 注意:
>
> 流程的另一个名称是任务。Linux内核在内部将进程称为任务。
>
> 在本书中交替使用这两个术语，不过当我说任务时，我通常是指从内核的观点来看的进程。