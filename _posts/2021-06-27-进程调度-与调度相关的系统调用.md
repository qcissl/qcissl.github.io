---
layout:     post
title:      "进程调度"
subtitle:   "与调度相关的系统调用"
header-img: "img/content/c-23.jpg"
header-mask: 0.2
tags:
    - Linux内核设计与实现
---



## 4.8 与调度相关的系统调用

​		Linux提供了一系列系统调用来管理调度器参数。这些系统调用允许操作进程优先级、调度策略和处理器关联，并提供显式机制将处理器交给其他任务的机制。

​		各种书籍和友好的系统手册页提供了对这些系统调用的参考(这些都是在C库中实现的，没有太多的包装器，它们只是调用系统调用)。表4.2列出了系统调用并提供了简要描述。系统调用是如何在内核中实现的，将在第5章系统调用中讨论。

|System |Call Description|
|----|----|
|`nice`() |设置进程的nice值|
|`sched_setscheduler`() |设置进程的调度策略|
|`sched_getscheduler`() |获取进程的调度策略|
|`sched_setparam`() |设置进程的实时优先级|
|`sched_getparam`() |获取进程的实时优先级|
|`sched_get_priority_max`() |获取最大实时优先级|
|`sched_get_priority_min`() |获取最小实时优先级|
|`sched_rr_get_interval`() |获取进程的时间片值|
|`sched_setaffinity`() |设置进程的处理器的亲和力|
|`sched_getaffinity`() |获取进程的处理器的亲和力|
|`sched_yield`() |临时让出处理器|



### 4.8.1 与调度策略和优先级相关的系统调用

​		`sched_setscheduler`()和`sched_getscheduler`()系统调用分别设置和获得给定进程的调度策略和实时优先级。它们的实现与大多数系统调用一样，涉及大量参数检查、设置和清理。然而，重要的工作仅仅是读或写进程的task_struct中的policy和rt_priority值。

​		`sched_setparam`()和`sched_getparam`()系统调用设置并获得进程的实时优先级。这些调用只是在一个特殊的`sched_param`结构中编码`rt_priority`。`sched_get_priority_max`()和`sched_get_priority_min`()调用分别返回给定调度策略的最大和最小优先级。实时策略的最大优先级为MAX_USER_RT_PRIO - 1;最小值是1。

​		对于普通任务，nice()函数将给定进程的静态优先级按给定值递增。只有根可以提供负值，从而降低nice值并增加优先级。nice()函数调用内核的set_user_nice()函数，该函数在任务的task_struct中适当地设置`static_prio`和`prio`值。

### 4.8.2 与处理器绑定有关的系统调用

​		Linux调度器提供了强制的处理器绑定机制。也就是说，尽管调度器试图通过提供软的（或者说自然的）亲和性试图让进程尽量在同一个处理器上运行，但它还允许用户强制指定，“这个进程必须保持在这些处理器的上运行”。这个强制的亲和性保存在进程的task_struct中的`cpus_allowed`这个位掩码标志中。该位掩码的每一个位对于系统上每个可用的处理器。默认情况下，所有位都已设置，因此进程可能可在任何处理器上运行。但是，用户可以通过`sched_setaffinity`()提供一个或多个位的任意组合的不同位掩码。同样，调用`sched_getaffinity`()返回当前`cpus_allowed`的位掩码。

​		内核提供的强制处理器绑定的方法很简单。

- 首先，在最初创建进程时，它将继承其父进程的相关掩码。因为父进程运行在一个指定的处理器上，所以子进程也运行在相应的处理器上。
- 其次，当处理器的绑定关系发生变化时，内核使用`迁移线程`将任务推到合法的处理器上。
- 最后，负载均衡器只将任务拉到一个允许的处理器。因此，一个进程只能在其进程描述符的`cpus_allowed`字段中设置位的处理器上运行。

### 4.8.3 放弃处理器时间

​		Linux提供了`sched_yield`()系统调用作为进程显式将处理器让给其他等待进程的机制。它的工作方式是将进程从活动数组中删除(它当前所在的位置，因为它正在运行)，并将其插入到过期的数组中。这不仅会抢占进程并将其放在优先级列表的末尾，还会将其放在过期列表上——保证它在一段时间内不会运行。因为实时任务永远不会过期，所以它们属于特殊情况。因此，它们只是移动到它们的优先级列表的末尾(而不是插入到过期的数组中)。在Linux的早期版本中，`sched_yield`()调用的语义非常不同；在最好的情况下，任务只被移动到其优先级列表的末尾。这种屈服通常不会持续很长时间。现在，应用程序甚至内核代码都应该在调用`sched_yield`()之前确定它们确实想放弃处理器。

​		内核代码可以方便地调用yield()，它确保任务的状态是TASK_RUNNING，然后调用`sched_yield`()。用户空间应用程序使用`sched_yield`()系统调用。

