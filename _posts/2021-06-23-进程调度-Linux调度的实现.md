---
layout:     post
title:      "进程调度"
subtitle:   "Linux调度的实现"
header-img: "img/content/c-21.jpg"
header-mask: 0.2
tags:
    - Linux内核设计与实现
---



## 4.5 Linux调度的实现

​		在讨论了CFS的动机和逻辑之后，我们现在可以研究CFS的实际实现，它位于`kernel/sched_fair.c`中。具体来说，我们讨论了CFS的四个组成部分：

- 时间记账
- 进账选择
- 调度器入口
- 睡眠和唤醒

### 4.5.1 时间记账

​		所有的调度器都必须对进程运行的时间做记账。大多数Unix系统通过为每个进程分配一个时间片来实现这一点。在系统时钟节拍发生时，时间片减去一个节拍周期。当时间片达到0时，该进程将被另一个尚未减到0的时间片的可运行进程抢占。

​		**调度器实体结构**

CFS不再有时间片的概念，但是他也必须维护每个进程运行的时间记账，因为他需要确保每个进程只在公平分配给他的处理器时间运行。CFS使用&lt;`linux/ schedule .h`&gt;中定义的调度器实体结构(`struct sched_entity`)来跟踪进程记帐：

```c
struct sched_entity {
    struct load_weight load;
    struct rb_node run_node;
    struct list_head group_node;
    unsigned int on_rq;
    u64 exec_start;
    u64 sum_exec_runtime;
    u64 vruntime;
    u64 prev_sum_exec_runtime;
    u64 last_wakeup;
    u64 avg_overlap;
    u64 nr_migrations;
    u64 start_runtime;
    u64 avg_wakeup;
    /* many stat variables elided, enabled only if CONFIG_SCHEDSTATS is set */
};
```

​		调度器实体结构作为一个名为se的成员变量，嵌入在进程描述符struct task_struct内。我们在第3章进程管理中讨论了进程描述符。

​		**虚拟运行时**

​		`vruntime`变量存放进程的虚拟运行时间（单位是纳秒），因此`vruntime`与计时器计时解耦了。虚拟运行时可以帮助我们近似出CFS所建模的理想多任务处理器。如果我们真的拥有一个理想的处理器，我们就不需要`vruntime`了，因为所有可运行的进程都可以完美地多任务。也就是说，在一个理想的处理器上，具有相同优先级的所有进程的虚拟运行时都应该是相同的，所有任务都应该获得平等、公平的处理器份额。因为处理器不具备完美的多任务处理能力，我们必须连续运行每个进程，CFS使用`vruntime`来计算一个进程已经运行了多长时间，从而计算它应该运行多长时间。在`kernel/sched_fair.c`中定义的函数`update_curr()`管理此计费：

```c
static void update_curr(struct cfs_rq *cfs_rq)
{
    struct sched_entity *curr = cfs_rq->curr;
    u64 now = rq_of(cfs_rq)->clock;
    unsigned long delta_exec;
    if (unlikely(!curr))
    	return;
    /*
    * Get the amount of time the current task was running
    * since the last time we changed load (this cannot
    * overflow on 32 bits):
    */
    delta_exec = (unsigned long)(now - curr->exec_start);
    if (!delta_exec)
    	return;
    __update_curr(cfs_rq, curr, delta_exec);
    curr->exec_start = now;
    if (entity_is_task(curr)) {
        struct task_struct *curtask = task_of(curr);
        trace_sched_stat_runtime(curtask, delta_exec, curr->vruntime);
        cpuacct_charge(curtask, delta_exec);
        account_group_exec_runtime(curtask, delta_exec);
    }
}
```

然后它将运行时间传递给__update_curr()，后者根据可运行进程的数量来权衡时间。然后将当前进程的vruntime值加1

```c
/*
* Update the current task’s runtime statistics. Skip current tasks that
* are not in our scheduling class.
*/
static inline void
__update_curr(struct cfs_rq *cfs_rq, struct sched_entity *curr,
unsigned long delta_exec)
{
    unsigned long delta_exec_weighted;
    schedstat_set(curr->exec_max, max((u64)delta_exec, curr->exec_max));
    curr->sum_exec_runtime += delta_exec;
    schedstat_add(cfs_rq, exec_clock, delta_exec);
    delta_exec_weighted = calc_delta_fair(delta_exec, curr);
    curr->vruntime += delta_exec_weighted;
    update_min_vruntime(cfs_rq);
}
```

通过这种方式，vruntime是对给定进程运行时的精确度量，并指示下一步应该运行什么进程。

### 4.5.2 进账选择

​		为了讨论公平调度，我们必须首先描述传统Unix系统如何调度进程。如上一节所述，现代进程调度器有两个常见概念：进程优先级和时间片。时间片是指进程运行的时间；进程一旦启动就会有一个默认时间片。具有更高优先级的进程运行更频繁，(在许多系统上)被赋予更多的时间片。在Unix上，优先级以nice值的形式导出到用户空间。这听起来很简单，但实际上它会导致一些反常的问题，我们现在就来讨论一下。

​		首先，若将nice值映射到时间片，就需要决定分配每个nice值的绝对时间片。这导致了进程切换无法最优化进行。例如，让我们假设我们给默认nice值(0)的进程分配一个100毫秒的时间片，给最高nice值(+20，最低优先级)的进程分配一个5毫秒的时间片。让我们假设这两个进程都处于可运行的状态。那么默认优先级的进程因此获得20/21(105毫秒中的100ms)处理器时间，而低优先级进程接收到1/21(105毫秒中的5ms)处理器时间。现在，如果我们恰好运行两个低优先级进程会发生什么？我们希望他们每个人都能得到处理器的50%，他们也确实做到了。但是它们每次只享受5毫秒的处理器时间(10毫秒中的5毫秒)！也就是说，我们现在每10毫秒切换两次上下文，而不是每105毫秒切换两次。相反，如果我们有两个正常的优先级进程，每个进程都会收到正确的50%的处理器，但是以100毫秒内各获得一半。这两种时间片分配都不是理想的；每个都是给定nice值到时间片映射与进程运行优先级混合的共同作用结果。事实上，考虑到高nice值(低优先级)的进程往往是后台的、处理器密集型任务，而正常优先级的进程往往是前台用户任务，这种时间片分配完全不理想！

​		第二个问题涉及到相对nice值以及时间片映射的nice值。假设我们有两个进程，每个进程都有一个nice值。首先，我们假设它们一个是0一个是1。这可能将(在O(1)调度器中确实如此)分别映射到100毫秒和95毫秒的时间片。这两个值几乎是相同的，因此两个nice值之间的差异很小。现在，我们假设两个进程的值分别是18和19。这将会映射到10毫秒和5毫秒的时间片，前者接收的处理器时间是后者的两倍！因为nice值最常用的是相对值(因为系统调用接受的是一个增量，而不是绝对值)，所以这种行为意味着，根据初始nice值的不同，将一个进程简化一个会产生非常不同的效果。

​		第三，如果对时间片映射执行一个nice值，我们需要能够分配一个绝对的时间片。这个绝对值必须能在内核的测试范围内。在大多数操作系统中，这意味着时间片必须是计时器频率的整数倍。(关于时间的讨论，请参见第11章计时器和时间管理。)这就带来了几个问题。首先，最小时间片必然是计时器震荡周期的下限，它可能高达10毫秒，也可能低至1毫秒。第二，系统计时器限制了两个时间片之间的差异：连续的nice值可能映射到10毫秒或1毫秒间隔的时间片。最后，时间片还会随着定时器的震荡而改变。(如果这段关于计时器滴答声的讨论是陌生的，请在读完第11章后再读一遍。这只是CFS背后的动机之一。)

​		第四个问题是处理基于优先级的调度器为了优化交互任务而唤醒相关进程。在这样的系统中，您可能希望新唤醒的进程立即运行而给它们一个优先级提升，即使它们的时间片已经过期。尽管这提高了大多数情况下的交互性能，但它也打开了利用调度器的后门，即某些睡眠/唤醒用例可能会欺骗调度器，以牺牲系统的其他部分为代价，为一个进程提供不公平的处理器时间。

​		这些问题中的大多数都可以通过对老式的Unix调度器进行改造解决，虽然改造的力度不小但是也非结构性重构。例如，用几何值代替加法值解决了第二个问题。使用与计时器计时分离的测量将nice值映射到时间片解决了第三个问题。但这样的解决方案掩盖了真正的问题，即分配绝对的时间片产生恒定的切换频率，给公平性造成很大的变数。CFS采用的方法是对时间片分配的彻底重新思考(对于进程调度器而言):完全废除时间片，而是为每个进程分配处理器的使用比重。因此，CFS保证了恒定的公平性，而且切换频率也是不断变动的。

### 4.5.3 调度器入口

​		CFS基于一个简单的概念：对进程调度进行建模，就好像系统有一个理想的、完美的多任务处理器。在这样的系统中，每个进程将接收处理器时间的1/n，其中n是可运行进程的数量，我们将调度给他们无限小的持续时间，这样在任何可测量的时间段内，我们给与n个进程中的每一个进程相同时间。例如，假设我们有两个进程。在标准的Unix模型中，我们可能运行一个进程5毫秒，然后运行另一个进程5毫秒。在运行时，每个进程将收到处理器的100%。在一个理想的、完美的多任务处理器中，我们会同时运行两个进程10毫秒，每个进程以50%的功率运行。后一种模式被称为完美多任务处理。

​		当然，这样的模型也不现实，因为在单个处理器上不可能同时运行多个进程。此外，在无限小的持续时间内运行进程是没有效率的。也就是说，将一个进程抢占给另一个进程是有切换成本的，例如，将一个进程交换给另一个进程的开销以及对影响缓存效率。因此，尽管我们希望运行进程的持续时间非常短，但CFS注意到这样做的开销和性能影响。相反，CFS将在一定时间内运行每个进程，循环运行，然后选择运行次数最少的进程作为下一个运行进程。CFS不是为每个进程分配一个时间片，而是根据可运行进程的总数计算一个进程应该运行多长时间。而不是使用nice值来计算一个时间片,CFS使用nice值获取处理器使用的权重:更高nice值(低优先级)进程获得更低的处理器使用权重,而更低的nice值(高优先级)进程获得更多的处理器使用权重。

​		每个进程都按其权重的全部可运行进程中所占比例的“时间片”来运行。为了计算准确的时间片，CFS为完美多任务中的无限小调度周期的近似值设立了一个目标。而这个目标被称作“目标延迟”，较小的目标可以产生更好的交互性和更接近完美的多任务处理，但代价是更高的切换成本，因此总体吞吐量更差。让我们假设目标延迟是20毫秒，并且我们有两个具有相同优先级的可运行任务。不管这些任务的优先级如何，每个任务都会运行10毫秒，然后才会抢占其他任务。如果我们有四个具有相同优先级的任务，那么每个任务将运行5毫秒。如果有20个任务，每个任务将运行1毫秒。

​		注意，当可运行任务的数量趋于无穷时，分配的处理器和分配的时间片的比例趋于零。由于这将最终导致不可接受的转换成本，CFS对分配给每个流程的时间片施加了一个下限。这一层叫做最小粒度。缺省值是1毫秒。因此，即使可运行进程的数量接近无穷大，每个进程将至少运行1毫秒，以确保产生的切换成本有一个上限。(精明的读者会注意到，当进程数量增长到如此之大，以至于计算出的比例以最小粒度为基准时，CFS并不是完全公平的。这是正确的。尽管存在对公平排队的修改以改善这种公平性，但CFS明确地设计了这种权衡。在只有少数几个可运行进程的常见情况下，CFS是完全公平的。)

​		现在，让我们再次考虑不同nice值的两个可运行进程的情况，比如，一个有默认的nice值(0)，一个有nice值5。这些好的值具有不同的权重，因此我们的两个进程获得不同比例的处理器时间。在这种情况下，对于nice为5的进程，权重的计算结果约为1/3。如果我们的目标延迟再次是20毫秒，我们的两个进程将分别收到15毫秒和5毫秒的处理器时间。假设我们的两个可运行进程的nice值是10和15，分配的时间片是什么?同样是15毫秒和5毫秒。绝对的nice值不再影响调度决策：只有相对值影响分配的处理器时间的比例。

​		一般来说，任何进程获得到的处理器时间是由他自己和其他可运行进程的nice值相对差值决定的。nice值不会对时间片产生算数加权，而是产生几何加权。分配给进程的任何nice值对应的时间片不再是一个绝对数字，而是处理器时间使用比例。CFS被称为公平调度器，因为它给每个进程公平地分配处理器时间使用比。如上所述，请注意CFS并不是完全公平的，因为它只是近似于完美的多任务处理，但它将不公平的n个可运行进程的延迟的下界确定为n。

### 4.5.4 睡眠和唤醒