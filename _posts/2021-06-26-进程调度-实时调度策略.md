---
layout:     post
title:      "进程调度"
subtitle:   "实时调度策略"
header-img: "img/content/c-23.jpg"
header-mask: 0.2
tags:
    - Linux内核设计与实现
---



## 4.7 实时调度策略

​		Linux提供了两个实时调度策略，`SCHED_FIFO`和`SCHED_RR`。正常的(非实时的)调度策略为`SCHED_NORMAL`。通过调度类框架，这些实时策略不是由完全公平调度器管理的，而是由`kernel/sched_rt.c`中定义的一个特殊的实时调度器管理的。本节的其余部分将讨论实时调度策略和算法。

​		SCHED_FIFO实现了一个简单的先入先出调度算法，不使用时间片。可运行的SCHED_FIFO进程总是在SCHED_NORMAL进程上优先调度。当SCHED_FIFO进程变为可运行时，它将继续运行，直到阻塞或显式地释放处理器为止；它不基于时间片，可以无限地运行。只有优先级更高的SCHED_FIFO或SCHED_RR进程可以抢占SCHED_FIFO进程。具有相同优先级的两个或多个SCHED_FIFO进程，她们会循环运行，但同样只有在它们愿意让出处理器是才会退出。如果SCHED_FIFO任务是可运行的，那么所有具有较低优先级的任务都不能运行，直到它变成不可运行。

​		SCHED_RR与SCHED_FIFO相同，只是每个进程只能运行到耗尽预定的时间片为止。也就是说，SCHED_RR是带有时间片的SCHED_FIFO——这是一种实时的轮循调度算法。当SCHED_RR任务耗尽其时间片时，在同一优先级的其他实时进程被轮流调度。时间片用于仅允许重新调度相同优先级的进程。与SCHED_FIFO一样，高优先级进程总是立即抢占低优先级进程，而低优先级进程永远不会抢占SCHED_RR任务，即使其时间片已耗尽。

​		这两种实时调度策略都实现静态优先级。内核不会为实时任务计算动态优先级值。这确保了给定优先级的实时进程总是抢占较低优先级的进程。

​		Linux中的实时调度策略提供软实时行为。软实时指的是内核试图在时间期限内安排应用程序，但内核不承诺总是实现这些目标。相反，硬实时系统保证在一定范围内满足任何调度要求。Linux没有保证调度实时任务的能力。尽管没有保证硬实时行为的设计，Linux中的实时调度性能还是相当不错的。Linux 2.6内核能够满足严格的计时要求。

​		实时优先级的范围从0到MAX_RT_PRIO - 1。默认情况下，MAX_RT_PRIO是100，因此，默认的实时优先级范围是0到99。这个优先级空间与SCHED_NORMAL任务的优秀值共享：它们使用从MAX_RT_PRIO到(MAX_RT_PRIO + 40)的空间。默认情况下，这意味着20到+19的nice范围直接映射到从100到139的优先级空间。