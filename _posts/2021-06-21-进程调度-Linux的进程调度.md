---
layout:     post
title:      "进程调度"
subtitle:   "Linux的进程调度"
header-img: "img/content/c-18.jpg"
header-mask: 0.2
tags:
    - Linux内核设计与实现
---



## 4.1 多任务

​		多任务操作系统是一种可以同时交错执行多个进程的系统。在单处理器机器上，这会产生多个进程并发运行的错觉。在多处理器机器上，这样的功能使进程能够在不同的处理器上并发地运行。在这两种类型的机器上，它还允许许多进程阻塞或休眠，直到工作可用时才真正执行。这些进程虽然在内存中，但不能运行。相反，这些进程利用内核等待某个事件(键盘输入、网络数据、时间等待等)发生。因此，现代Linux系统在内存中可以有许多进程，但只有一个处于可运行状态。

​		多任务操作系统有两种:非抢占式多任务和抢占式多任务。Linux与所有Unix变体和大多数现代操作系统一样，实现了抢占式多任务。在抢占式多任务处理中，调度程序决定什么时候一个进程停止运行，什么时候一个新的进程开始运行。强制挂起正在运行的进程的行为称为抢占。进程在被抢占之前运行的时间通常是预先确定的，它被称为进程的时间片。实际上，时间片就是给每个可运行进程一个处理器时间段。管理时间片使调度程序能够为系统做出全局调度决策。它还可以防止任何一个进程独占系统资源。在许多现代操作系统上，都采用了动态时间片计算的方式，并引入了可配置的计算策略。正如我们将看到的，Linux独特的公平调度程序本身并不使用时间片，来达到公平的效果。

​		相反，在非抢占式多任务模式下，除非进程自己主动停止运行，否则他会一直执行。进程主动挂起自己的行为称为让步。理想情况下，进程通常会让步，给每个可运行进程一个适当的处理器块，但操作系统不能强制执行这一点。这种方法的缺点很明显:调度程序不能就进程运行多长时间做出全局决策；进程可以垄断处理器的时间超过用户的期望；而一个挂起的进程永远不作出让步，可能会导致整个系统崩溃。值得庆幸的是，过去20年设计的大多数操作系统都采用了抢占式多任务处理，其中Mac OS 9(更早)和Windows 3.1(更早)是最显著的(也最尴尬的)例外。当然，Unix从一开始就提倡抢占式多任务。

## 4.2 Linux的进程调度

​		从1991年Linux的第一个版本到2.4内核系列，Linux调度程序在设计上是简单的，几乎是原始的。它很容易理解，但是伸缩性很差，但是他在众多可运行进程或多处理器的环境下难以胜任。

​		正因如此，在2.5内核开发系列中，Linux内核进行了一次调度c程序的大调整。一种新的调度程序(由于其算法行为通常称为O(1)调度程序)。他解决了以前Linux调度程序的缺点，并引入了强大的新特性和性能特征。通过引入用于静态时间片算法和针对每处理器运行队列的恒定时间算法，它纠正了早期调度器的设计限制。

​		O(1)调度器虽然在支持有数十个(不是数百个)处理器的环境下尚能表现出近乎完美的性能和可扩展性。然而，随着时间的推移，O(1)调度器明显出现了一些与响应时间敏感的应用程序上的一些先天不足。这些应用程序称为交互进程，包括与用户交互的任何应用程序。因此，虽然O(1)调度器对于缺少交互进程的大型服务器工作负载是理想的，但它在桌面系统上表现不佳，因为其缺少交互进程。在2.6内核系列的早期，开发人员引入了新的进程调度器，旨在改进O(1)调度器的交互性能。其中最值得注意的是”反转楼梯最后期限调度算法“（RSDL），它借用排队理论，将公平调度的概念用到Linux的进程调度器。这个概念在2.6.23内核版本中替代O(1)调度程序，即完全公平调度程序(CFS)。

​		本章讨论调度器设计的基本原理，以及它们如何应用于完全公平调度器，以及它的目标、设计、实现、算法和相关的系统调用。我们还将讨论O(1)调度器，因为它的实现是更经典的Unix进程调度器模型。
