---
layout:     post
title:      "进程调度"
subtitle:   "调度策略"
header-img: "img/content/c-19.jpg"
header-mask: 0.2
tags:
    - Linux内核设计与实现
---



## 4.3 策略

​		策略是调度程序的行为，它决定什么时候运行什么进程。调度器策略通常决定系统的整体感觉，并负责优化利用处理器时间。因此，这非常重要。

### 4.3.1 I/O消耗型和CPU消耗型进程

​		进程可以分为I/O消耗型和CPU消耗型。前者的特点是花费大量时间提交和等待I/O请求。因此，这样的进程只能运行很短的时间，因为它最终会阻塞等待更多的I/O。(这里的I/O指的是任何类型的可阻塞资源，如键盘输入或网络I/O，而不仅仅是磁盘I/O)，例如，大多数图形用户界面(GUI)应用程序都是I/O约束的，即使它们从未从磁盘读取或写入磁盘，因为它们的大部分时间都花在通过键盘和鼠标等待用户交互上。

​		相反，CPU消耗型进程花费大量时间执行代码。它们会一直运行到被抢占为止，因为它们不会经常阻塞I/O请求。但是，由于它们不是I/O驱动的，系统响应并不要求调度器经常运行它们。因此，处理器消耗型进程的调度器策略倾向于较少地运行此类进程，但运行时间会更长。处理器消耗型进程的极端示例是执行无限循环的进程。更合适的例子包括执行大量数学计算的程序，例如sshkeygen或MATLAB。

​		当然，这些分类不是相互排斥的。进程可以同时显示这两种行为:例如，X Window服务器既是处理器消耗型又是I/O消耗型。其他进程可能是I/O消耗型，但又会进入密集的处理器操作阶段。一个很好的例子就是文字处理器，它通常等待按键，但在任何时候都可能使处理器陷入拼写检查或宏计算的疯狂计算状态。

​		系统中的调度策略必须尝试满足两个冲突的目标:快速处理响应时间(低延迟)和最大系统利用率(高吞吐量)。为了满足这些不确定的需求，调度器经常使用复杂的算法来确定最值得运行的进程，同时不牺牲对其他低优先级进程的公平性。Unix系统中的调度器策略倾向于显式地支持I/O消耗型进程，从而提供良好的进程响应时间。Linux的目标是提供良好的交互响应和桌面性能，它针对进程响应(低延迟)进行了优化，从而使I/O消耗型的进程优于处理器消耗型的进程。正如我们将看到的，这是以一种创造性的方式完成的，没有忽略处理器消耗型的进程。

### 4.3.2 进程优先级

​		一种常见的调度算法是基于优先级的调度。其目标是根据进程的价值和对处理器时间的需求对进程进行排序。其基本思想是，具有较高优先级的进程优先运行，而具有相同优先级的进程被调度为轮循，这在Linux上并没有完全实现。在某些系统上，具有较高优先级的进程也会收到较长的时间片。未耗尽时间片且具有最高优先级的可运行进程始终运行。用户和系统都可以通过设置进程的优先级来影响系统的调度行为。

​		Linux内核实现了两个独立的优先级范围。第一个是nice值，一个从-20到+19的数字，默认值为0。较大的nice值对应较低的优先级，nice意味着您对系统中的其他进程更优待。拥有较低nice值(较高优先级)的进程与拥有较高nice值(较低优先级)的进程相比，将获得更大比例的系统处理器时间。Nice值是所有Unix系统中使用的标准优先级范围，尽管不同的Unix系统以不同的方式应用它们，反映了它们各自的调度算法。在其他基于unix的系统中，比如Mac OS X, nice值是对分配给进程的绝对时间片的控制;在Linux中，它是对时间片比例的控制。您可以通过命令ps -el看到系统上的进程列表以及它们各自的nice值(在标记为NI的列下)。

​		第二个范围是实时优先级。这些值是可配置的，但默认范围为0到99(含99)。与nice值相反，更高的实时优先级值对应更高的优先级。所有实时进程比正常进程具有更高的优先级；也就是说，实时优先级和nice值处于不相交的两个范畴。Linux按照相关Unix标准，特别是POSIX.1b实现实时优先级。所有现代Unix系统都实现了类似的方案。您可以使用该命令查看系统上的进程列表及其相应的实时优先级(在标记为RTPRIO的列下)

```
ps -eo state,uid,pid,ppid,rtprio,time,comm.
```

​		对应列显示`-`表示过程不是实时的进程。

### 4.3.3 时间片

​		时间片是表示进程在被抢占之前可以运行多长时间的数值。调度器策略必须指定一个默认的时间片，这不是一个简单的事情。时间片过长，系统交互性能较差;系统将不再觉得应用程序是并发执行的。太短的时间片会导致大量的处理器时间浪费在进程切换的开销上，因为系统时间的很大一部分被花费在从一个具有短时间片的进程切换到下一个进程上。此外，I/O消耗型进程与处理器消耗型进程的目标冲突再次出现：I/O消耗型进程不需要更长的时间片(尽管它们喜欢经常运行)，而处理器消耗型进程需要更长的时间片(以保持缓存的热度)。

​		有了这个参数，似乎任何长的时间片都会导致较差的交互性能。在许多操作系统中，这一观察结果非常重要，默认的时间片相当低，例如10毫秒。然而，Linux的CFS调度器并不直接为进程分配时间片。相反，在一种新的方法中，CFS将处理器的一部分分配给进程。因此，在Linux上，进程接收到的处理器时间是系统负载的一个函数。这个分配的比例进一步受到每个进程的nice值的影响。nice值充当权重，改变每个进程接收到的处理器时间的比例。具有较高的nice值(较低的优先级)的进程接收一个低权重，从而使它们在处理器中所占的比例更小；具有较小nice值(较高优先级)的进程将获得一个高权重，从而使它们在处理器中占更大的比例。

​		如前所述，Linux操作系统是抢占式的。当进程进入可运行状态时，它就有资格运行。在大多数操作系统中，进程是否立即运行、抢占当前运行的进程取决于进程的优先级和可用的时间片。在Linux中，在新的CFS调度器下，决策取决于新可运行处理器消耗了多少处理器的比例。如果它占用的处理器份额小于当前正在执行的进程，它将立即运行，抢占当前进程。如果没有，它将被安排在稍后运行。



### 4.3.4 调度策略的活动

​		考虑一个具有两个可运行任务的系统:一个文本编辑器和一个视频编码器。文本编辑器是I/O消耗型的，因为它几乎把所有的时间都花在等待用户按下键上。当文本编辑器接收到按键时，用户希望编辑器立即响应。相反，视频编码器是处理器消耗型的。除了从磁盘读取原始数据流并随后写入生成的视频之外，编码器将所有时间用于将视频编解码器应用于原始数据，轻松地消耗了100%的处理器。视频编码器没有任何强烈的时间限制，如果它现在开始运行或在半秒内开始运行，用户不能知道，也不会关心。当然，完成得越快越好，但延迟不是主要问题。

​		在这种情况下，理想情况下，调度程序为文本编辑器提供比视频编码器更大比例的可用处理器，因为文本编辑器是交互式的。对于文本编辑器，我们有两个目标。首先，我们希望它有大量可用的处理器时间；不是因为它需要大量的处理器(实际上并没有)，而是因为我们希望它在需要的时候总是有可用的处理器时间。其次，我们希望文本编辑器在视频编码器苏醒时(例如，当用户按下一个键时)抢占它。这可以确保文本编辑器具有良好的交互性能，并响应用户输入。在大多数操作系统上，这些目标是通过赋予文本编辑器比视频编码器更高的优先级和更大的时间片来实现的(如果有的话)。高级操作系统通过检测文本编辑器是交互式的，自动完成这一操作。Linux也实现了这些目标，但方式不同。它不是为文本编辑器分配特定的优先级和时间片，而是保证文本编辑器处理程序的特定比例。比如视频编码器和文本编辑器是仅有的两个运行的进程，并且两者处于相同的nice级别，那么这一比例将为50%，每个都将保证一半的处理器时间。因为文本编辑器的大部分时间都被阻塞了，等待用户按下键，所以它不会使用接近50%的处理器。相反，视频编码器是绝对可以使用超过分配的50%，使其能够快速完成编码。

​		关键的概念是当文本编辑器醒来时发生了什么。我们的主要目标是确保它在用户输入时立即运行。在这种情况下，当编辑器醒来时，CFS注意到它被分配了处理器的50%，但使用的却少得多。具体来说，CFS确定文本编辑器运行的时间少于视频编码器。它试图给所有进程一个公平的处理器份额，然后抢占视频编码器，并使文本编辑器运行。文本编辑器运行，快速处理用户的按键，然后再次休眠，等待更多的输入。由于文本编辑器没有使用其分配的50%，我们继续使用这种方式，CFS总是允许文本编辑器在需要时运行，视频编码器在其余时间运行。
