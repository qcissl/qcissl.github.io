---
layout:     post
title:      "进程调度"
subtitle:   "Syscalls"
header-img: "img/content/c-26.jpg"
header-mask: 0.2
tags:
    - Linux内核设计与实现
---



## 5.3 Syscalls

​		系统调用(通常在Linux中称为syscall)，通常通过C库中定义的函数调用进行访问。它们可以定义零个、一个或多个参数(输入)，并可能导致一个或多个副作用，例如写入文件或将一些数据复制到提供的指针。系统调用还提供一个类型为long的返回值，该返回值通常表示成功或错误，尽管并非总是如此，但负返回值表示错误。返回值为0通常(但也不总是)是成功的标志。当系统调用返回错误时，C库将一个特殊的错误代码写入全局变量errno中。这个变量可以通过perror()等库函数转换为人类可读的错误。

​		当然，系统调用有一个明确的操作。例如，系统调用getpid()被定义为返回一个整数，即当前进程的PID。这个系统调用在内核中的实现很简单：

```c
SYSCALL_DEFINE0(getpid) 
{
	return task_tgid_vnr(current); // returns current->tgid 
}
```

​		注意，定义没有提到他要如何实现。内核必须提供系统调用的预期行为，但只要结果是正确的，它可以自由地按照自己预期的方式去实现。当然，这个上面提到的系统调用非常简单，并且没有太多的其他方法来实现它。

​		SYSCALL_DEFINE0只是一个宏，它定义了一个没有参数的系统调用(因此是0)。展开的代码如下所示:

```c
asmlinkage long sys_getpid(void)
```

​		我们看一下如何定义系统调用。首先，注意函数定义上的asmlinkage修饰符。这是一个编译指令，告诉编译器只在堆栈上查找该函数的参数。这是所有系统调用都需要的修饰符。第二，函数返回一个long。为了兼容32位和64位系统，在用户空间中定义返回int的系统调用在内核中返回long。第三，注意getpid()系统调用在内核中定义为sys_getpid()。这是Linux中所有系统调用的命名约定:系统调用bar()在内核中实现为函数sys_bar()。



### 5.3.1 系统调用号

​		在Linux中，每个系统调用都被分配一个系统调用号。这是一个唯一的号码，用于引用特定的系统调用。当用户空间进程执行系统调用时，系统调用号标识执行的是哪个系统调用；进程不通过名称引用系统调用。

​		系统调用号很重要；当分配给它时，它不能更改，否则编译后的应用程序将崩溃。同样地，如果一个系统调用被删除，那么它的系统调用号就不能被回收，或者之前编译的代码将以调用一个系统调用为目标，但实际上会调用另一个系统调用。Linux提供了一个未实现的系统调用sys_ni_syscall()，它除了返回-ENOSYS外什么也不做，这是一个与无效系统调用对应的错误。此函数用于在系统调用被删除或以其他方式不可用的罕见事件中堵塞漏洞。

​		内核在系统调用表中保存了所有注册系统调用的列表，存储在sys_call_table中。每一种结构体系中都明确的定义这个表；在x86-64中，它在`arch/i386/kernel/syscall_64.c`中定义。该表为每个有效的系统调用分配一个唯一的系统调用号。

### 5.3.2 系统调用的性能

​		Linux中的系统调用比许多其他操作系统中的要快。Linux快速的上下文切换时间是一个重要的原因；进入和退出内核是一件简化而简单的事情。另一个因素是系统调用处理程序和单个系统调用自身的简洁性。
