---
layout:     post
title:      "进程调度"
subtitle:   "抢占和上下文切换"
header-img: "img/content/c-22.jpg"
header-mask: 0.2
tags:
    - Linux内核设计与实现
---



## 4.6 抢占和上下文切换

​		上下文切换，即从一个可运行进程切换到另一个可运行进程，由`kernel/schedule.c`中定义的context_switch()函数处理。当一个新进程被选择运行时，schedule()会调用它。它做两个基本工作:

1. 调用switch_mm()，它在&lt;`asm/mmu_context.h`&gt;中声明，将虚拟内存映射从上一个进程切换到新进程。
2. 调用switch_to()，它在&lt; `asm/system.h`&gt;中声明，上一个进程的处理器状态切换过程到当前的进程的处理器状态。这包括保存和恢复堆栈信息和处理器寄存器，还有任何其他与体系结构相关的状态信息，都必须以每个进程为对象进程管理和保存。

​		但是，内核必须知道何时调用schedule()。如果只有在用户代码显式地调用schedule()时才调用它，那么用户空间程序可以无限地运行。相反，内核提供了`need_resched`标志来表示是否应该执行重调度(参见表4.1)。当一个进程被抢占时，scheduler_tick()设置这个标志；当一个进程的优先级高于当前运行的进程被唤醒时，try_to_wake_up()设置这个标志。内核检查这个标志，看到它被设置了，然后调用schedule()来切换到一个新的进程。该标志是给内核的一条消息，即应该尽快调用调度程序，因为需要运行另一个进程。

**用于访问和操作`need_resched`的函数**

|Function |Purpose|
|----|----|
|`set_tsk_need_resched`() |在给定进程中设置`need_resched`标志。|
|`clear_tsk_need_resched`() |清除给定进程中的`need_resched`标志。|
|`need_resched`() |测试`need_resched`标志的值；如果设置则返回true，否则返回false。|

​		当返回到用户空间或从中断返回时，内核也会检查`need_resched`标志。如果设置了它，内核将在继续之前调用调度程序。

​		每个进程都包涵一个`need_resched`，这是因为访问进程描述符中的值比访问一个全局变量更快(因为current宏的速度很快并且进程描述符通常都在高速缓存中)。在2.2以前的内核版本中，这个标志是全局的。在2.2和2.4中，标志是task_struct内部的一个`int`。在2.6中，它被移到了thread_info结构中，用一个特殊标志变量的一位来表示。

### 4.6.1 用户抢占

​		当内核准备返回到用户空间，如果设置了`need_resched`，因此会导致schedule()被调用，此时就会发生用户抢占。如果内核正在返回到用户空间，那么它知道它处于安全的状态。换句话说，如果继续执行当前任务是安全的，那么选择要执行的新任务也是安全的。因此，当内核准备从中断返回或在系统调用之后返回到用户空间时，都会检查`need_resched`标志。如果设置了它，则调用调度器来选择一个新的(更适合的)进程来执行。从中断处理程序或系统调用返回的返回路径都是依赖于体系结构的，在`entry.S`（此文件不仅包含内核入口部分的程序，内核退出部分的相关代码也在其中）文件中通过汇编语言来实现。

​		简而言之，用户抢占在一下情况下产生：

- 从系统调用返回到用户空间时
- 从中断处理程序返回用户空间时

### 4.6.2 内核抢占

​		Linux内核不同于大多数其他Unix变体和许多其他操作系统，它是一个完全抢占式的内核。在非抢占式内核中，内核代码会一直运行直到完成。也就是说，调度程序不能在内核级进程正在执行的时候重新调度任务——内核代码是协同调度的，而不是抢占调度的，内核代码运行到它完成(返回到用户空间)或显式阻塞为止。然而，在2.6内核中，Linux内核变成了抢占式：现在只要内核处于可以安全重新调度的状态，就可以在任何时候抢占任务。

​		那什么时候重新调度才是安全的呢?只要内核不持有锁，它就可以抢占在内核中运行的任务。也就是说，锁是非抢占区域的标记。因为内核是`SMP`安全的，所以如果没有持有锁，当前代码是可重入的，并且能够被抢占。

​		为了支持内核抢占所做的第一个变化是在每个进程的thread_info中增加了一个抢占计数器`preempt_count`。这个计数器从0开始，每获得一个锁就增加一次，每释放一个锁就减少一次。当计数器为0时，内核是可抢占的。当从中断返回时，如果返回到内核空间，内核将检查`need_resched`和`preempt_count`的值。如果设置了`need_resched`并且`preempt_count`为0，那么更重要的任务是可运行的，抢占是安全的。这样，调度程序就被调用了。如果`preempt_count`不为零，则持有一个锁，重新调度是不安全的。在这种情况下，中断会像往常一样返回到当前正在执行的进程。当当前进程持有的所有锁都被释放时，preempt_count返回0。此时，解锁代码检查是否设置了`need_resched`。如果是，则调用调度程序。在内核代码中有时需要启用和禁用内核抢占，这将在第9章中讨论。

​		当内核中的任务阻塞或显式调用schedule()时，也可以显式地发生内核抢占。这种形式的内核抢占一直都受到支持，因为不需要额外的逻辑来确保内核处于可以安全抢占的状态。我们假定显式调用schedule()的代码知道重新调度是安全的。

​		内核抢占可能发生在：

- 当中断处理程序退出，在返回内核空间之前
- 当内核代码再次具有可抢占性的时候
- 如果内核中的任务显式调用schedule()
- 如果内核中的任务阻塞(这导致调用schedule())

